# -*- coding: utf-8 -*-
"""GaussJordan.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1e2XP9GZKf2hMirIdp73kNKNv2vWKdsUQ

Gauss Jordan
"""

import numpy as np
import sympy

class GaussJordan:
    
    """
        Método para intercambiar dos filas de la matriz M
        Entradas: indices de la primer y segunda fila 
        Salidas: Matriz M modificada
    """
    def intercambiarFilas(self, index1, index2, M): 
        for i in range(len(M[0])): # itera sobre el número de columnas
            tmp = M[index2][i]
            M[index2][i] = M[index1][i]
            M[index1][i] = tmp
        return M
   
    def multiplicarFila(self, k, fila, colInicial, M):
        for i in range (colInicial, len(M[0])):
            M[fila][i] = k * M[fila][i]
        return M

    """
        Método empleado para realizar la eliminación resta dos filas
        Entradas: indices de  filas 1 y 2, columna inicial y Matriz
        Salida: Matriz M modficada
    """
    def restarFilas(self, f1, f2, colInicial, M):
        for i in range(colInicial, len(M[0])):
            M[f1][i] =  M[f2][i] - M[f1][i]
        return M 

    """
        Método para buscar un elemento pivote, se implementa pivoteo parcial
        Entradas: filas, columna actual y matriz
        Salidas: Matriz modificada
    """
    def buscarPivote(self, filas, col, M):
        indiceFila = -1
        maxNum = np.inf *-1
        for i in range(col+1, filas):
            if(M[i][col] > maxNum and M[i][col] != 0):
                indiceFila = i
                maxNum = M[i][col]
        return indiceFila

    """
        Método para efectuar la eliminación Gaussiana
        Entradas: Número de filas y columnas, Matriz
        Salida: Matriz modificada
    """
    def eliminacionGaussiana(self, f, c, M):
        # Definición de variables
        indicePiv = -1
        
        for i in range(f):
            pivote = M[i][i]
            if pivote == 0:
                indicePiv = self.buscarPivote(f, i, M) # Se implementa pivoteo parcial
                #TODO: Implementar pivoteo completo
                if indicePiv == -1:
                    print("El sistema no tiene solución")
                    exit(0)
                else:
                    M = self.intercambiarFilas(indicePiv, i, M)
                    pivote = M[i][i]
            
            for j in range(i+1, f): # Realizar la eliminación de los elementos debajo del pivote
                if M[j][i] != 0:
                    k = pivote / M[j][i]    # Multiplicador para la eliminación
                    M = self.multiplicarFila(k, j, i, M)
                    M = self.restarFilas(j, i, i, M)
        #print("Matriz resultante EG: \n", M)

    def GJ(self,f,c,M):
        for i in range(f):
            pivote=M[-1-i][-2-f-i]
            M[-1-i]=M[-1-i]/pivote
            for j in range(f-1-i):
                M[j]=M[j]-M[j][-2-f-i]*M[-1-i]
        #print("Matriz resultante: \n", M)

"""
    Método para calcular la inversa de una matriz M
    Entradas: Filas, columnas y Matriz original
    Salida: Matriz inversa
"""
def calculateInverse(f, c, M, objG):
    # Definición de matriz identidad
    I = np.identity(f)
    print("Identidad: \n", I)

    #corregir número de columnas
    c=c+f
    MAug = np.concatenate([M,I], axis=1)
    print("Matriz aumentada: \n", MAug)
    # Generar matriz aumentada
    objG.eliminacionGaussiana(f,c,MAug)
    objG.GJ(f,c,MAug)
    print(MAug)
    print("Sólo matriz inversa:")
    for i in range(f):
      print(MAug[i][f+1:c]) #imprime todas las filas, de la fila f+1 hasta la c-1
    
def main():

    # Definición de número de filas y columnas
    f = 3
    c = f+1 # +1 se debe a la columna de resultados
    
    # Inicializar una matriz de 
    M = np.random.randint(10, size = (f,c))

    print("matrix aleatoria:\n", M)
    
    # Creación de un objeto
    objG = GaussJordan() # objG es una variable de la clase "GaussJordan"
    #print("Realizando eliminación Gaussiana...\n")
    #objG.eliminacionGaussiana(f, c, M) # aplicar el método eliminacionGaussiana en objG
    #objG.GJ(f,c,M)
    print("Cálculo de matriz inversa:\n")
    calculateInverse(f,c,M,objG)





if __name__ == "__main__":
    main()
